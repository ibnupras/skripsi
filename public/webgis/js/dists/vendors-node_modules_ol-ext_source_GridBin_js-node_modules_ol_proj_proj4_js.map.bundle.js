"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_ol-ext_source_GridBin_js-node_modules_ol_proj_proj4_js"],{

/***/ "./node_modules/ol-ext/geom/GeomUtils.js":
/*!***********************************************!*\
  !*** ./node_modules/ol-ext/geom/GeomUtils.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"extentIntersection\": () => (/* binding */ ol_extent_intersection),\n/* harmony export */   \"ol_coordinate_dist2d\": () => (/* binding */ ol_coordinate_dist2d),\n/* harmony export */   \"ol_coordinate_equal\": () => (/* binding */ ol_coordinate_equal),\n/* harmony export */   \"ol_coordinate_findSegment\": () => (/* binding */ ol_coordinate_findSegment),\n/* harmony export */   \"ol_coordinate_getFeatureCenter\": () => (/* binding */ ol_coordinate_getFeatureCenter),\n/* harmony export */   \"ol_coordinate_getGeomCenter\": () => (/* binding */ ol_coordinate_getGeomCenter),\n/* harmony export */   \"ol_coordinate_getIntersectionPoint\": () => (/* binding */ ol_coordinate_getIntersectionPoint),\n/* harmony export */   \"ol_coordinate_offsetCoords\": () => (/* binding */ ol_coordinate_offsetCoords),\n/* harmony export */   \"ol_coordinate_sampleAt\": () => (/* binding */ ol_coordinate_sampleAt),\n/* harmony export */   \"ol_coordinate_splitH\": () => (/* binding */ ol_coordinate_splitH),\n/* harmony export */   \"ol_extent_intersection\": () => (/* binding */ ol_extent_intersection),\n/* harmony export */   \"ol_geom_createFromType\": () => (/* binding */ ol_geom_createFromType)\n/* harmony export */ });\n/* harmony import */ var ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/geom/LineString.js */ \"./node_modules/ol/geom/LineString.js\");\n/* harmony import */ var ol_geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/geom/LinearRing.js */ \"./node_modules/ol/geom/LinearRing.js\");\n/* harmony import */ var ol_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/geom/MultiLineString.js */ \"./node_modules/ol/geom/MultiLineString.js\");\n/* harmony import */ var ol_geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/geom/MultiPoint.js */ \"./node_modules/ol/geom/MultiPoint.js\");\n/* harmony import */ var ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/geom/MultiPolygon.js */ \"./node_modules/ol/geom/MultiPolygon.js\");\n/* harmony import */ var ol_geom_Point_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/geom/Point.js */ \"./node_modules/ol/geom/Point.js\");\n/* harmony import */ var ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/geom/Polygon.js */ \"./node_modules/ol/geom/Polygon.js\");\n/* harmony import */ var ol_geom_Circle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/geom/Circle.js */ \"./node_modules/ol/geom/Circle.js\");\n/* harmony import */ var ol_extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/extent.js */ \"./node_modules/ol/extent.js\");\n/*\tCopyright (c) 2016 Jean-Marc VIGLINO, \r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n\r\n  Usefull function to handle geometric operations\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** Distance beetween 2 points\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {number} distance\r\n */\r\nvar ol_coordinate_dist2d = function(p1, p2) {\r\n  var dx = p1[0]-p2[0];\r\n  var dy = p1[1]-p2[1];\r\n  return Math.sqrt(dx*dx+dy*dy);\r\n}\r\n\r\n/** 2 points are equal\r\n *\tUsefull geometric functions\r\n * @param {ol.Coordinate} p1 first point\r\n * @param {ol.Coordinate} p2 second point\r\n * @return {boolean}\r\n */\r\nvar ol_coordinate_equal = function(p1, p2) {\r\n  return (p1[0]==p2[0] && p1[1]==p2[1]);\r\n}\r\n\r\n/** Get center coordinate of a feature\r\n * @param {ol.Feature} f\r\n * @return {ol.coordinate} the center\r\n */\r\nvar ol_coordinate_getFeatureCenter = function(f) {\r\n  return ol_coordinate_getGeomCenter (f.getGeometry());\r\n};\r\n\r\n/** Get center coordinate of a geometry\r\n* @param {ol.geom.Geometry} geom\r\n* @return {ol.Coordinate} the center\r\n*/\r\nvar ol_coordinate_getGeomCenter = function(geom) {\r\n  switch (geom.getType()) {\r\n    case 'Point': \r\n      return geom.getCoordinates();\r\n    case \"MultiPolygon\":\r\n      geom = geom.getPolygon(0);\r\n      // fallthrough\r\n    case \"Polygon\":\r\n      return geom.getInteriorPoint().getCoordinates();\r\n    default:\r\n      return geom.getClosestPoint((0,ol_extent_js__WEBPACK_IMPORTED_MODULE_0__.getCenter)(geom.getExtent()));\r\n  }\r\n};\r\n\r\n/** Offset a polyline\r\n * @param {Array<ol.Coordinate>} coords\r\n * @param {number} offset\r\n * @return {Array<ol.Coordinate>} resulting coord\r\n * @see http://stackoverflow.com/a/11970006/796832\r\n * @see https://drive.google.com/viewerng/viewer?a=v&pid=sites&srcid=ZGVmYXVsdGRvbWFpbnxqa2dhZGdldHN0b3JlfGd4OjQ4MzI5M2Y0MjNmNzI2MjY\r\n */\r\nvar ol_coordinate_offsetCoords = function (coords, offset) {\r\n  var path = [];\r\n  var N = coords.length-1;\r\n  var max = N;\r\n  var mi, mi1, li, li1, ri, ri1, si, si1, Xi1, Yi1;\r\n  var p0, p1, p2;\r\n  var isClosed = ol_coordinate_equal(coords[0],coords[N]);\r\n  if (!isClosed) {\r\n    p0 = coords[0];\r\n    p1 = coords[1];\r\n    p2 = [\r\n      p0[0] + (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] - (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n    coords.push(coords[N])\r\n    N++;\r\n    max--;\r\n  }\r\n  for (var i = 0; i < max; i++) {\r\n    p0 = coords[i];\r\n    p1 = coords[(i+1) % N];\r\n    p2 = coords[(i+2) % N];\r\n\r\n    mi = (p1[1] - p0[1])/(p1[0] - p0[0]);\r\n    mi1 = (p2[1] - p1[1])/(p2[0] - p1[0]);\r\n    // Prevent alignements\r\n    if (Math.abs(mi-mi1) > 1e-10) {\r\n      li = Math.sqrt((p1[0] - p0[0])*(p1[0] - p0[0])+(p1[1] - p0[1])*(p1[1] - p0[1]));\r\n      li1 = Math.sqrt((p2[0] - p1[0])*(p2[0] - p1[0])+(p2[1] - p1[1])*(p2[1] - p1[1]));\r\n      ri = p0[0] + offset*(p1[1] - p0[1])/li;\r\n      ri1 = p1[0] + offset*(p2[1] - p1[1])/li1;\r\n      si = p0[1] - offset*(p1[0] - p0[0])/li;\r\n      si1 = p1[1] - offset*(p2[0] - p1[0])/li1;\r\n      Xi1 = (mi1*ri1-mi*ri+si-si1) / (mi1-mi);\r\n      Yi1 = (mi*mi1*(ri1-ri)+mi1*si-mi*si1) / (mi1-mi);\r\n\r\n      // Correction for vertical lines\r\n      if(p1[0] - p0[0] == 0) {\r\n        Xi1 = p1[0] + offset*(p1[1] - p0[1])/Math.abs(p1[1] - p0[1]);\r\n        Yi1 = mi1*Xi1 - mi1*ri1 + si1;\r\n      }\r\n      if (p2[0] - p1[0] == 0 ) {\r\n        Xi1 = p2[0] + offset*(p2[1] - p1[1])/Math.abs(p2[1] - p1[1]);\r\n        Yi1 = mi*Xi1 - mi*ri + si;\r\n      }\r\n\r\n      path.push([Xi1, Yi1]);\r\n    }\r\n  }\r\n  if (isClosed) {\r\n    path.push(path[0]);\r\n  } else {\r\n    coords.pop();\r\n    p0 = coords[coords.length-1];\r\n    p1 = coords[coords.length-2];\r\n    p2 = [\r\n      p0[0] - (p1[1] - p0[1]) / ol_coordinate_dist2d(p0,p1) *offset,\r\n      p0[1] + (p1[0] - p0[0]) / ol_coordinate_dist2d(p0,p1) *offset\r\n    ];\r\n    path.push(p2);\r\n  }\r\n  return path;\r\n}\r\n\r\n/** Find the segment a point belongs to\r\n * @param {ol.Coordinate} pt\r\n * @param {Array<ol.Coordinate>} coords\r\n * @return {} the index (-1 if not found) and the segment\r\n */\r\nvar ol_coordinate_findSegment = function (pt, coords) {\r\n  for (var i=0; i<coords.length-1; i++) {\r\n    var p0 = coords[i];\r\n    var p1 = coords[i+1];\r\n    if (ol_coordinate_equal(pt, p0) || ol_coordinate_equal(pt, p1)) {\r\n      return { index:1, segment: [p0,p1] };\r\n    } else {\r\n      var d0 = ol_coordinate_dist2d(p0,p1);\r\n      var v0 = [ (p1[0] - p0[0]) / d0, (p1[1] - p0[1]) / d0 ];\r\n      var d1 = ol_coordinate_dist2d(p0,pt);\r\n      var v1 = [ (pt[0] - p0[0]) / d1, (pt[1] - p0[1]) / d1 ];\r\n      if (Math.abs(v0[0]*v1[1] - v0[1]*v1[0]) < 1e-10) {\r\n        return { index:1, segment: [p0,p1] };\r\n      }\r\n    }\r\n  }\r\n  return { index: -1 };\r\n};\r\n\r\n/**\r\n * Split a Polygon geom with horizontal lines\r\n * @param {Array<ol.Coordinate>} geom\r\n * @param {number} y the y to split\r\n * @param {number} n contour index\r\n * @return {Array<Array<ol.Coordinate>>}\r\n */\r\nvar ol_coordinate_splitH = function (geom, y, n) {\r\n  var x, abs;\r\n  var list = [];\r\n  for (var i=0; i<geom.length-1; i++) {\r\n    // Hole separator?\r\n    if (!geom[i].length || !geom[i+1].length) continue;\r\n    // Intersect\r\n    if (geom[i][1]<=y && geom[i+1][1]>y || geom[i][1]>=y && geom[i+1][1]<y) {\r\n      abs = (y-geom[i][1]) / (geom[i+1][1]-geom[i][1]);\r\n      x = abs * (geom[i+1][0]-geom[i][0]) + geom[i][0];\r\n      list.push ({ contour: n, index: i, pt: [x,y], abs: abs });\r\n    }\r\n  }\r\n  // Sort x\r\n  list.sort(function(a,b) { return a.pt[0] - b.pt[0] });\r\n  // Horizontal segment\r\n  var result = [];\r\n  for (var j=0; j<list.length-1; j += 2) {\r\n    result.push([list[j], list[j+1]])\r\n  }\r\n  return result;\r\n};\r\n\r\n/** Create a geometry given a type and coordinates */\r\nvar ol_geom_createFromType = function (type, coordinates) {\r\n  switch (type) {\r\n    case 'LineString': return new ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](coordinates);\r\n    case 'LinearRing': return new ol_geom_LinearRing_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](coordinates);\r\n    case 'MultiLineString': return new ol_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](coordinates);\r\n    case 'MultiPoint': return new ol_geom_MultiPoint_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](coordinates);\r\n    case 'MultiPolygon': return new ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](coordinates);\r\n    case 'Point': return new ol_geom_Point_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](coordinates);\r\n    case 'Polygon': return new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](coordinates);\r\n    default:\r\n      console.error('[createFromType] Unsupported type: '+type);\r\n      return null;\r\n  }\r\n};\r\n\r\n\r\n\r\n\r\n/** Intersect 2 lines\r\n * @param {Arrar<ol.coordinate>} d1\r\n * @param {Arrar<ol.coordinate>} d2\r\n */\r\nvar ol_coordinate_getIntersectionPoint = function (d1, d2) {\r\n  var d1x = d1[1][0] - d1[0][0];\r\n  var d1y = d1[1][1] - d1[0][1];\r\n  var d2x = d2[1][0] - d2[0][0];\r\n  var d2y = d2[1][1] - d2[0][1];\r\n  var det = d1x * d2y - d1y * d2x;\r\n  if (det != 0) {\r\n    var k = (d1x * d1[0][1] - d1x * d2[0][1] - d1y * d1[0][0] + d1y * d2[0][0]) / det;\r\n    return [d2[0][0] + k*d2x, d2[0][1] + k*d2y];\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n\r\n\r\nvar ol_extent_intersection;\r\n\r\n(function() {\r\n// Split at x\r\nfunction splitX(pts, x) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][0]>x && pts[i-1][0]<x) || (pts[i][0]<x && pts[i-1][0]>x)) {\r\n      pt = [ x, (x - pts[i][0]) / (pts[i-1][0]-pts[i][0]) * (pts[i-1][1]-pts[i][1]) + pts[i][1]];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n// Split at y\r\nfunction splitY(pts, y) {\r\n  var pt;\r\n  for (let i=pts.length-1; i>0; i--) {\r\n    if ((pts[i][1]>y && pts[i-1][1]<y) || (pts[i][1]<y && pts[i-1][1]>y)) {\r\n      pt = [ (y - pts[i][1]) / (pts[i-1][1]-pts[i][1]) * (pts[i-1][0]-pts[i][0]) + pts[i][0], y];\r\n      pts.splice(i, 0, pt);\r\n    }\r\n  }\r\n}\r\n\r\n/** Fast polygon intersection with an extent (used for area calculation)\r\n * @param {ol_extent_Extent} extent\r\n * @param {ol_geom_Polygon|ol_geom_MultiPolygon} polygon\r\n * @returns {ol_geom_Polygon|ol_geom_MultiPolygon|null} return null if not a polygon geometry\r\n */\r\nol_extent_intersection = function(extent, polygon) {\r\n  var poly = (polygon.getType() === 'Polygon');\r\n  if (!poly && polygon.getType() !== 'MultiPolygon') return null;\r\n  var geom = polygon.getCoordinates();\r\n  if (poly) geom = [geom];\r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      splitX(c, extent[0]);\r\n      splitX(c, extent[2]);\r\n      splitY(c, extent[1]);\r\n      splitY(c, extent[3]);\r\n    });\r\n  })\r\n  // Snap geom to the extent \r\n  geom.forEach(function(g) {\r\n    g.forEach(function(c) {\r\n      c.forEach(function(p) {\r\n        if (p[0]<extent[0]) p[0] = extent[0];\r\n        else if (p[0]>extent[2]) p[0] = extent[2];\r\n        if (p[1]<extent[1]) p[1] = extent[1];\r\n        else if (p[1]>extent[3]) p[1] = extent[3];\r\n      })\r\n    })\r\n  })\r\n  if (poly) {\r\n    return new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](geom[0]);\r\n  } else {\r\n    return new ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](geom);\r\n  }\r\n};\r\n})();\r\n\r\n\r\n\r\n\r\n/** Add points along a segment\r\n * @param {ol_Coordinate} p1 \r\n * @param {ol_Coordinate} p2 \r\n * @param {number} d \r\n * @param {boolean} start include starting point, default true\r\n * @returns {Array<ol_Coordinate>}\r\n */\r\nvar ol_coordinate_sampleAt = function(p1, p2, d, start) {\r\n  var pts = [];\r\n  if (start!==false) pts.push(p1);\r\n  var dl = ol_coordinate_dist2d(p1,p2);\r\n  if (dl) {\r\n    var nb = Math.round(dl/d);\r\n    if (nb>1) {\r\n      var dx = (p2[0]-p1[0]) / nb;\r\n      var dy = (p2[1]-p1[1]) / nb;\r\n      for (var i=1; i<nb; i++) {\r\n        pts.push([p1[0] + dx*i, p1[1] + dy*i])\r\n      }\r\n    }\r\n  }\r\n  pts.push(p2);\r\n  return pts;\r\n};\r\n\r\n\r\n/** Sample a LineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_LineString}\r\n */\r\nol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype.sampleAt = function(d) {\r\n  var line = this.getCoordinates();\r\n  var result = [];\r\n  for (var i=1; i<line.length; i++) {\r\n    result = result.concat(ol_coordinate_sampleAt(line[i-1], line[i], d, i===1));\r\n  }\r\n  return new ol_geom_LineString_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](result);\r\n};\r\n\r\n/** Sample a MultiLineString at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_MultiLineString}\r\n */\r\nol_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].prototype.sampleAt = function(d) {\r\n  var lines = this.getCoordinates();\r\n  var result = [];\r\n  lines.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], d, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_MultiLineString_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](result);\r\n};\r\n\r\n/** Sample a Polygon at a distance\r\n * @param {number} d\r\n * @returns {ol_geom_Polygon}\r\n */\r\nol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].prototype.sampleAt = function(res) {\r\n  var poly = this.getCoordinates();\r\n  var result = [];\r\n  poly.forEach(function(p) {\r\n    var l = [];\r\n    for (var i=1; i<p.length; i++) {\r\n      l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n    }\r\n    result.push(l);\r\n  })\r\n  return new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](result);\r\n};\r\n\r\n/** Sample a MultiPolygon at a distance\r\n * @param {number} res\r\n * @returns {ol_geom_MultiPolygon}\r\n */\r\nol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].prototype.sampleAt = function(res) {\r\n  var mpoly = this.getCoordinates();\r\n  var result = [];\r\n  mpoly.forEach(function(poly) {\r\n    var a = [];\r\n    result.push(a);\r\n    poly.forEach(function(p) {\r\n      var l = [];\r\n      for (var i=1; i<p.length; i++) {\r\n        l = l.concat(ol_coordinate_sampleAt(p[i-1], p[i], res, i===1));\r\n      }\r\n      a.push(l);\r\n    })\r\n  });\r\n  return new ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](result);\r\n};\r\n\r\n/** Intersect a geometry using a circle\r\n * @param {ol_geom_Geometry} geom\r\n * @param {number} resolution circle resolution to sample the polygon on the circle, default 1\r\n * @returns {ol_geom_Geometry}\r\n */\r\nol_geom_Circle_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].prototype.intersection = function(geom, resolution) {\r\n  if (geom.sampleAt) {\r\n    var ext = (0,ol_extent_js__WEBPACK_IMPORTED_MODULE_0__.buffer)(this.getCenter().concat(this.getCenter()), this.getRadius());\r\n    geom = ol_extent_intersection(ext, geom);\r\n    geom = geom.simplify(resolution);\r\n    var c = this.getCenter();\r\n    var r = this.getRadius();\r\n    //var res = (resolution||1) * r / 100;\r\n    var g = geom.sampleAt(resolution).getCoordinates();\r\n    switch (geom.getType()) {\r\n      case 'Polygon': g = [g];\r\n        // fallthrough\r\n      case 'MultiPolygon': {\r\n        var hasout = false;\r\n        // var hasin = false;\r\n        var result = [];\r\n        g.forEach(function(poly) {\r\n          var a = [];\r\n          result.push(a);\r\n          poly.forEach(function(ring) {\r\n            var l = [];\r\n            a.push(l);\r\n            ring.forEach(function(p) {\r\n              var d = ol_coordinate_dist2d(c, p);\r\n              if (d > r) {\r\n                hasout = true;\r\n                l.push([\r\n                  c[0] + r / d * (p[0]-c[0]),\r\n                  c[1] + r / d * (p[1]-c[1])\r\n                ]);\r\n              } else {\r\n                // hasin = true;\r\n                l.push(p);\r\n              }\r\n            });\r\n          })\r\n        });\r\n        if (!hasout) return geom;\r\n        if (geom.getType() === 'Polygon') {\r\n          return new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](result[0]);\r\n        } else {\r\n          return new ol_geom_MultiPolygon_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](result);\r\n        }\r\n      }\r\n    }\r\n  } else {\r\n    console.warn('[ol/geom/Circle~intersection] Unsupported geometry type: '+geom.getType());\r\n  }\r\n  return geom;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/ol-ext/geom/GeomUtils.js?");

/***/ }),

/***/ "./node_modules/ol-ext/source/BinBase.js":
/*!***********************************************!*\
  !*** ./node_modules/ol-ext/source/BinBase.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ol_Feature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/Feature.js */ \"./node_modules/ol/Feature.js\");\n/* harmony import */ var ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/geom/Polygon.js */ \"./node_modules/ol/geom/Polygon.js\");\n/* harmony import */ var ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/source/Vector.js */ \"./node_modules/ol/source/Vector.js\");\n/* harmony import */ var _geom_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geom/GeomUtils.js */ \"./node_modules/ol-ext/geom/GeomUtils.js\");\n/* harmony import */ var _Vector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector.js */ \"./node_modules/ol-ext/source/Vector.js\");\n/*\tCopyright (c) 2019 Jean-Marc VIGLINO,\r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n/** Abstract base class; normally only used for creating subclasses. Bin collector for data\r\n * @constructor\r\n * @extends {ol.source.Vector}\r\n * @param {Object} options ol_source_VectorOptions + grid option\r\n *  @param {ol.source.Vector} options.source Source\r\n *  @param {boolean} options.listenChange listen changes (move) on source features to recalculate the bin, default true\r\n *  @param {fucntion} [options.geometryFunction] Function that takes an ol.Feature as argument and returns an ol.geom.Point as feature's center.\r\n *  @param {function} [options.flatAttributes] Function takes a bin and the features it contains and aggragate the features in the bin attributes when saving\r\n */\r\nvar ol_source_BinBase = class olsourceBinBase extends ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n  constructor(options) {\r\n    options = options || {};\r\n    super(options);\r\n\r\n    this._bindModify = this._onModifyFeature.bind(this);\r\n    this._watch = true;\r\n    this._origin = options.source;\r\n    this._listen = (options.listenChange !== false);\r\n\r\n    // Geometry function\r\n    this._geomFn = options.geometryFunction || _geom_GeomUtils_js__WEBPACK_IMPORTED_MODULE_0__.ol_coordinate_getFeatureCenter || function (f) { return f.getGeometry().getFirstCoordinate(); };\r\n\r\n    // Future features\r\n    this._origin.on('addfeature', this._onAddFeature.bind(this));\r\n    this._origin.on('removefeature', this._onRemoveFeature.bind(this));\r\n    this._origin.on('clearstart', this._onClearFeature.bind(this));\r\n    this._origin.on('clearend', this._onClearFeature.bind(this));\r\n    if (typeof (options.flatAttributes) === 'function') {\r\n      this._flatAttributes = options.flatAttributes;\r\n    }\r\n\r\n    // Handle exsting feature (should be called from children when fully created)\r\n    // this.reset()\r\n  }\r\n  /**\r\n   * On add feature\r\n   * @param {ol.events.Event} e\r\n   * @param {ol.Feature} bin\r\n   * @private\r\n   */\r\n  _onAddFeature(e, bin, listen) {\r\n    var f = e.feature || e.target;\r\n    bin = bin || this.getBinAt(this._geomFn(f), true);\r\n    if (bin)\r\n      bin.get('features').push(f);\r\n    if (this._listen && listen !== false)\r\n      f.on('change', this._bindModify);\r\n  }\r\n  /**\r\n   *  On remove feature\r\n   *  @param {ol.events.Event} e\r\n   *  @param {ol.Feature} bin\r\n   *  @private\r\n   */\r\n  _onRemoveFeature(e, bin, listen) {\r\n    if (!this._watch)\r\n      return;\r\n    var f = e.feature || e.target;\r\n    bin = bin || this.getBinAt(this._geomFn(f));\r\n    if (bin) {\r\n      // Remove feature from bin\r\n      var features = bin.get('features');\r\n      for (var i = 0, fi; fi = features[i]; i++) {\r\n        if (fi === f) {\r\n          features.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n      // Remove bin if no features\r\n      if (!features.length) {\r\n        this.removeFeature(bin);\r\n      }\r\n    } else {\r\n      // console.log(\"[ERROR:Bin] remove feature: feature doesn't exists anymore.\");\r\n    }\r\n    if (this._listen && listen !== false)\r\n      f.un('change', this._bindModify);\r\n  }\r\n  /** When clearing features remove the listener\r\n   * @private\r\n   */\r\n  _onClearFeature(e) {\r\n    if (e.type === 'clearstart') {\r\n      if (this._listen) {\r\n        this._origin.getFeatures().forEach(function (f) {\r\n          f.un('change', this._bindModify);\r\n        }.bind(this));\r\n      }\r\n      this.clear();\r\n      this._watch = false;\r\n    } else {\r\n      this._watch = true;\r\n    }\r\n  }\r\n  /**\r\n   * Get the bin that contains a feature\r\n   * @param {ol.Feature} f the feature\r\n   * @return {ol.Feature} the bin or null it doesn't exit\r\n   */\r\n  getBin(feature) {\r\n    var bins = this.getFeatures();\r\n    for (var i = 0, b; b = bins[i]; i++) {\r\n      var features = b.get('features');\r\n      for (var j = 0, f; f = features[j]; j++) {\r\n        if (f === feature)\r\n          return b;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  /** Get the grid geometry at the coord\r\n   * @param {ol.Coordinate} coord\r\n   * @param {Object} attributes add key/value to this object to add properties to the grid feature\r\n   * @returns {ol.geom.Polygon}\r\n   * @api\r\n   */\r\n  getGridGeomAt(coord /*, attributes */) {\r\n    return new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]([coord]);\r\n  }\r\n  /** Get the bean at a coord\r\n   * @param {ol.Coordinate} coord\r\n   * @param {boolean} create true to create if doesn't exit\r\n   * @return {ol.Feature} the bin or null it doesn't exit\r\n   */\r\n  getBinAt(coord, create) {\r\n    var attributes = {};\r\n    var g = this.getGridGeomAt(coord, attributes);\r\n    if (!g)\r\n      return null;\r\n    var center = g.getInteriorPoint ? g.getInteriorPoint().getCoordinates() : g.getInteriorPoints().getCoordinates()[0]; // ol_extent_getCenter(g.getExtent());\r\n    var features = this.getFeaturesAtCoordinate(center);\r\n    var bin = features[0];\r\n    if (!bin && create) {\r\n      attributes.geometry = g;\r\n      attributes.features = [];\r\n      attributes.center = center;\r\n      bin = new ol_Feature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](attributes);\r\n      this.addFeature(bin);\r\n    }\r\n    return bin || null;\r\n  }\r\n  /**\r\n   *  A feature has been modified\r\n   *  @param {ol.events.Event} e\r\n   *  @private\r\n   */\r\n  _onModifyFeature(e) {\r\n    var bin = this.getBin(e.target);\r\n    var bin2 = this.getBinAt(this._geomFn(e.target), 'create');\r\n    if (bin !== bin2) {\r\n      // remove from the bin\r\n      if (bin) {\r\n        this._onRemoveFeature(e, bin, false);\r\n      }\r\n      // insert in the new bin\r\n      if (bin2) {\r\n        this._onAddFeature(e, bin2, false);\r\n      }\r\n    }\r\n    this.changed();\r\n  }\r\n  /** Clear all bins and generate a new one.\r\n   */\r\n  reset() {\r\n    this.clear();\r\n    var features = this._origin.getFeatures();\r\n    for (var i = 0, f; f = features[i]; i++) {\r\n      this._onAddFeature({ feature: f });\r\n    }\r\n    this.changed();\r\n  }\r\n  /**\r\n   * Get features without circular dependencies (vs. getFeatures)\r\n   * @return {Array<ol.Feature>}\r\n   */\r\n  getGridFeatures() {\r\n    var features = [];\r\n    this.getFeatures().forEach(function (f) {\r\n      var bin = new ol_Feature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](f.getGeometry().clone());\r\n      for (var i in f.getProperties()) {\r\n        if (i !== 'features' && i !== 'geometry') {\r\n          bin.set(i, f.get(i));\r\n        }\r\n      }\r\n      bin.set('nb', f.get('features').length);\r\n      this._flatAttributes(bin, f.get('features'));\r\n      features.push(bin);\r\n    }.bind(this));\r\n    return features;\r\n  }\r\n  /** Create bin attributes using the features it contains when exporting\r\n   * @param {ol.Feature} bin the bin to export\r\n   * @param {Array<ol.Features>} features the features it contains\r\n   */\r\n  _flatAttributes( /*bin, features*/) {\r\n  }\r\n  /** Set the flatAttribute function\r\n   * @param {function} fn Function that takes a bin and the features it contains and aggragate the features in the bin attributes when saving\r\n   */\r\n  setFlatAttributesFn(fn) {\r\n    if (typeof (fn) === 'function')\r\n      this._flatAttributes = fn;\r\n  }\r\n  /**\r\n   * Get the orginal source\r\n   * @return {ol_source_Vector}\r\n   */\r\n  getSource() {\r\n    return this._origin;\r\n  }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ol_source_BinBase);\r\n\n\n//# sourceURL=webpack:///./node_modules/ol-ext/source/BinBase.js?");

/***/ }),

/***/ "./node_modules/ol-ext/source/GridBin.js":
/*!***********************************************!*\
  !*** ./node_modules/ol-ext/source/GridBin.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _BinBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinBase.js */ \"./node_modules/ol-ext/source/BinBase.js\");\n/* harmony import */ var ol_proj_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/proj.js */ \"./node_modules/ol/proj.js\");\n/* harmony import */ var ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/geom/Polygon.js */ \"./node_modules/ol/geom/Polygon.js\");\n/*\tCopyright (c) 2019 Jean-Marc VIGLINO,\r\n  released under the CeCILL-B license (French BSD license)\r\n  (http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt).\r\n*/\r\n\r\n\r\n\r\n\r\n/** A source for grid binning\r\n * @constructor\r\n * @extends {ol.source.Vector}\r\n * @param {Object} options ol_source_VectorOptions + grid option\r\n *  @param {ol.source.Vector} options.source Source\r\n *  @param {number} [options.size] size of the grid in meter, default 200m\r\n *  @param {function} [options.geometryFunction] Function that takes an ol.Feature as argument and returns an ol.geom.Point as feature's center.\r\n *  @param {function} [options.flatAttributes] Function takes a bin and the features it contains and aggragate the features in the bin attributes when saving\r\n */\r\nvar ol_source_GridBin = class olsourceGridBin extends _BinBase_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n  constructor(options) {\r\n    options = options || {};\r\n\r\n    super(options);\r\n\r\n    this.set('gridProjection', options.gridProjection || 'EPSG:4326');\r\n    this.setSize('size', options.size || 1);\r\n    this.reset();\r\n  }\r\n  /** Set grid projection\r\n   * @param {ol.ProjectionLike} proj\r\n   */\r\n  setGridProjection(proj) {\r\n    this.set('gridProjection', proj);\r\n    this.reset();\r\n  }\r\n  /** Set grid size\r\n   * @param {number} size\r\n   */\r\n  setSize(size) {\r\n    this.set('size', size);\r\n    this.reset();\r\n  }\r\n  /** Get the grid geometry at the coord\r\n   * @param {ol.Coordinate} coord\r\n   * @returns {ol.geom.Polygon}\r\n   * @api\r\n   */\r\n  getGridGeomAt(coord) {\r\n    coord = (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_1__.transform)(coord, this.getProjection() || 'EPSG:3857', this.get('gridProjection'));\r\n    var size = this.get('size');\r\n    var x = size * Math.floor(coord[0] / size);\r\n    var y = size * Math.floor(coord[1] / size);\r\n    var geom = new ol_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([[[x, y], [x + size, y], [x + size, y + size], [x, y + size], [x, y]]]);\r\n    return geom.transform(this.get('gridProjection'), this.getProjection() || 'EPSG:3857');\r\n  }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ol_source_GridBin);\r\n\n\n//# sourceURL=webpack:///./node_modules/ol-ext/source/GridBin.js?");

/***/ }),

/***/ "./node_modules/ol-ext/source/Vector.js":
/*!**********************************************!*\
  !*** ./node_modules/ol-ext/source/Vector.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/source/Vector.js */ \"./node_modules/ol/source/Vector.js\");\n(function () {\r\n  var clear = ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype.clear;\r\n\r\n  /** Overwrite ol/source/Vector clear to fire clearstart / clearend event\r\n   */\r\n  ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype.clear = function(opt_fast) {\r\n    this.dispatchEvent({ type: 'clearstart' });\r\n    clear.call(this, opt_fast)\r\n    this.dispatchEvent({ type: 'clearend' });\r\n  };\r\n})();\r\n\n\n//# sourceURL=webpack:///./node_modules/ol-ext/source/Vector.js?");

/***/ }),

/***/ "./node_modules/ol/proj/proj4.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/proj4.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fromEPSGCode\": () => (/* binding */ fromEPSGCode),\n/* harmony export */   \"getEPSGLookup\": () => (/* binding */ getEPSGLookup),\n/* harmony export */   \"isRegistered\": () => (/* binding */ isRegistered),\n/* harmony export */   \"register\": () => (/* binding */ register),\n/* harmony export */   \"setEPSGLookup\": () => (/* binding */ setEPSGLookup),\n/* harmony export */   \"unregister\": () => (/* binding */ unregister)\n/* harmony export */ });\n/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Projection.js */ \"./node_modules/ol/proj/Projection.js\");\n/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ \"./node_modules/ol/proj.js\");\n/* harmony import */ var _transforms_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transforms.js */ \"./node_modules/ol/proj/transforms.js\");\n/**\n * @module ol/proj/proj4\n */\n\n\n\n\n/**\n * @type {import(\"proj4\")|null}\n */\nlet registered = null;\n\n/**\n * @return {boolean} Proj4 has been registered.\n */\nfunction isRegistered() {\n  return !!registered;\n}\n\n/**\n * Unsets the shared proj4 previously set with register.\n */\nfunction unregister() {\n  registered = null;\n}\n\n/**\n * Make projections defined in proj4 (with `proj4.defs()`) available in\n * OpenLayers. Requires proj4 >= 2.8.0.\n *\n * This function should be called whenever changes are made to the proj4\n * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be\n * modified by this function.\n *\n * @param {import(\"proj4\")} proj4 Proj4.\n * @api\n */\nfunction register(proj4) {\n  registered = proj4;\n\n  const projCodes = Object.keys(proj4.defs);\n  const len = projCodes.length;\n  let i, j;\n  for (i = 0; i < len; ++i) {\n    const code = projCodes[i];\n    if (!(0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code)) {\n      const def = proj4.defs(code);\n      let units = /** @type {import(\"./Units.js\").Units} */ (def.units);\n      if (!units && def.projName === 'longlat') {\n        units = 'degrees';\n      }\n      (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.addProjection)(\n        new _Projection_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n          code: code,\n          axisOrientation: def.axis,\n          metersPerUnit: def.to_meter,\n          units,\n        })\n      );\n    }\n  }\n  for (i = 0; i < len; ++i) {\n    const code1 = projCodes[i];\n    const proj1 = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code1);\n    for (j = 0; j < len; ++j) {\n      const code2 = projCodes[j];\n      const proj2 = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(code2);\n      if (!(0,_transforms_js__WEBPACK_IMPORTED_MODULE_2__.get)(code1, code2)) {\n        if (proj4.defs[code1] === proj4.defs[code2]) {\n          (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.addEquivalentProjections)([proj1, proj2]);\n        } else {\n          const transform = proj4(code1, code2);\n          (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.addCoordinateTransforms)(\n            proj1,\n            proj2,\n            (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createSafeCoordinateTransform)(proj1, proj2, transform.forward),\n            (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.createSafeCoordinateTransform)(proj2, proj1, transform.inverse)\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {number} code The EPSG code.\n * @return {Promise<string>} The proj4 definition.\n */\nlet epsgLookup = async function (code) {\n  const response = await fetch(`https://epsg.io/${code}.proj4`);\n  if (!response.ok) {\n    throw new Error(`Unexpected response from epsg.io: ${response.status}`);\n  }\n  return response.text();\n};\n\n/**\n * Set the lookup function for getting proj4 definitions given an EPSG code.\n * By default, the {@link module:ol/proj/proj4.fromEPSGCode} function uses the\n * epsg.io website for proj4 definitions.  This can be changed by providing a\n * different lookup function.\n *\n * @param {function(number):Promise<string>} func The lookup function.\n * @api\n */\nfunction setEPSGLookup(func) {\n  epsgLookup = func;\n}\n\n/**\n * Get the current EPSG lookup function.\n *\n * @return {function(number):Promise<string>} The EPSG lookup function.\n */\nfunction getEPSGLookup() {\n  return epsgLookup;\n}\n\n/**\n * Get a projection from an EPSG code.  This function fetches the projection\n * definition from the epsg.io website, registers this definition for use with\n * proj4, and returns a configured projection.  You must call import proj4 and\n * call {@link module:ol/proj/proj4.register} before using this function.\n *\n * If the projection definition is already registered with proj4, it will not\n * be fetched again (so it is ok to call this function multiple times with the\n * same code).\n *\n * @param {number|string} code The EPSG code (e.g. 4326 or 'EPSG:4326').\n * @return {Promise<Projection>} The projection.\n * @api\n */\nasync function fromEPSGCode(code) {\n  if (typeof code === 'string') {\n    code = parseInt(code.split(':').pop(), 10);\n  }\n\n  const proj4 = registered;\n  if (!proj4) {\n    throw new Error('Proj4 must be registered first with register(proj4)');\n  }\n\n  const epsgCode = 'EPSG:' + code;\n  if (proj4.defs(epsgCode)) {\n    return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(epsgCode);\n  }\n\n  proj4.defs(epsgCode, await epsgLookup(code));\n  register(proj4);\n\n  return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(epsgCode);\n}\n\n\n//# sourceURL=webpack:///./node_modules/ol/proj/proj4.js?");

/***/ })

}]);